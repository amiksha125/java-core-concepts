# Basics

The CPU, often referred to as the brain of the computer, is responsible for executing instruction from programs.
It performs basic arithmetic, logic, control, and input/output operations specified by the instructions.
Examples: A modern CPU like Intel core or AMD Ryzen 7

A core is an individual processing unit within a CPU. Modern CPU can have multiple cores, allowing them to perform
multiple tasks simultaneously.
A quad-core processor has four cores, allowing it to perform four tasks simultaneously. For instance, one core could handle
your web browser, another your music player, another a download manager, and another a background system update.

A program is a set of instructions written in a programming language that tells the computer how to perform a specific tasks
Example, Microsoft Word is a program that allows user to create and edit documents

A process is an instance of a program that is being executed. When a program runs, the operating system crates a process
to manage its execution.
Example, when we open Microsoft Word it becomes process in the operating system

A thread is the smallest unit of execution within a process. A process can have multiple threads, which share the same
resources but can run independently.
Example, A web browser like Chrome might use multiple threads for different tabs, with each tab running as a separate
thread.

# Multitasking

Multitasking allows an operating system to run multiple processes simultaneously. On single-core CPU, this
is done through time sharing, rapidly switching between tasks. On multi-core CPUs, true parallel
execution occurs, with tasks distributed across cores. The OS scheduler balances the load, ensuring efficient
and response system performance.
Example, Suppose we are browsing the internet while listening to music and downloading a file.
It utilizes the capabilities of CPU and its cores. When an operating system performs multitasking, it can assign
different tasks to different cores. This is more efficient then assigning all tasks to a single core.

# Multithreading

Multithreading refers to the ability to execute multiple threads within a single process simultaneously.
Example, A browser can use multithreading by having separate threads for rendering the page, running JavaScript,
and managing their inputs. This makes browser more responsive and efficient.

Read carefully - multithreading enhances the efficiency of multitasking by breaking down individual tasks into
smaller sub-tasks or threads. These threads can be processes simultaneously, making better use of CPU's
capabilities

In a single core system : Both threads and processes are managed by  OS scheduler through time slicing and
context switching to create the illusion of simultaneous execution.

In a multi-core system: Both threads and processes can run in true parallel on different cores.

Time Slicing: Divides CPU's time into smaller intervals called time slices or quanta.
The OS scheduler allocates these time slices to different processes and threads , ensuring
each gets a fair share of CPU time. This prevents any single process or threads from monopolizing the CPU.

 Context Switching: It is the process of saving the state of currently running process or threads and loading
 the state of next one to be executed. When a process or thread's time slice expires the OS scheduler
 performs a context switch to move the CPU's focus to another process or thread.

 Multitasking can be achieved through multithreading where each task is divided into threads that are managed
 concurrently. While multitasking typically refers to the running of multiple application, multithreading is more
 granular, dealing with multiple threads within the same application or process.

Multitasking operates at the level of processes, which are the operating system's primary unit of execution.
Multithreading operates at the level of threads, which are smaller units within a process.

 Multitasking involves managing resources between completely separate programs, which may have independent
 memory spaces and system resources
Multithreading involves managing resources within a single program, where thread share the same memory and resources

Multitasking allows us to run multiple application simultaneously, while multithreading allows a single application
to perform multiple tasks at the same time.

The office's manager(OS) assigns different employees(processes) to work on different projects (applications) simultaneously.
Each employee works on a different project independently.

Within a single project(application), a team(process) of employee(threads) works on different parts of the project
at the same time


Java's simple hello world program is also a process, it can be divided into into multiple threads see
at the end you can see at console -> Process finished with exit code 0

Java provides robust support for multithreading, allowing developers to create applications that can
perform multiple tasks simultaneously, improving performance and responsiveness

In Java, multithreading is the execution of two or more threads to maximize the utilization of CPU.
Java's multithreading capabilities are the part of the java.lang package, making easy to implement concurrent execution.

 In a single core environment, Java's multithreading is manages by the JVM and the OS, which switch between thread to give
 the illusion of concurrency.
 The thread share the single core, and the time slicing used to manage thread execution.

 In a multicore environment, java can take full advantage of multiple cores, the JVM can distribute threads across
 multiple cores.

 Thread is a lightweight process, the smallest unit of processing.

 Java supports multithreading through its java.lang.Thread and the java.lang.Runnable interface.

 ** When a Java program starts, one thread begins running immediately, which is called the main thread. This thread
 is responsible for executing the main method of a program. **

 To get the name of the thread running currently:
 Thread.currentThread().getName()

Two ways of creating a thread in Java:
1.
 To create a thread, create a new class that extends Thread and override the run() method of Thread.
 Te run it, create the object of the class that extends the Thread in the main method and : className.start()

# A new class World is created that extends Thread. The run method is overridden to defines the code that constitutes
the new thread. start method is called to initiate the new thread.

2.
  Create a new class that implements runnable, override the run method by adding here the task
  # To start thread execution, first create the object of class that has run then pass this object
  as an argument to Thread class constructor : Thread t1 = new Thread(world), then t1.start();

# A new class World is created that implements Runnable. The run method is overridden to defines the code that constitutes
  the new thread. A Thread object is created by passing an instance of MyRunnable. start method is called on the Thread object
  to initiate the new thread.

In both cases, the run method contains the code that will be executed in the new thread.

# Thread Lifecycle

The lifecycle of a thread in Java consists of several states, which a thread can move through during its execution.
New: A thread is in this state when it is created but not  yet started. eg. World world = new World()
Runnable: After the start method is called, the thread becomes runnable. Its ready to run and is waiting for CPU time.
 eg, world.start()
Running: The thread is in this state when it is executing. eg, code inside run() executes
Blocked / Waiting: A thread in this state when it is waiting for a resource or for another thread to perform an action.
Terminated: A thread is in this state when it has finished executing.

# thraedObject.getState() to get the state of thread
check out MyThread.java

use runnable when a thread is extending another class, as multiple inheritance not allowed in Java you can only implement Runnable
class A extends B implements Runnable{}

# Thread methods
 start, sleep. join
 setPriority(Thread.MIN_PRIORITY)
 MIN_PRIORITY = 1
 MAX_PRIORITY = 10
 NORM_PRIORITY = 5

interrupt, interrupt the run method

# synchronized : The synchronized keyword in Java is used to control access to shared resources in a multithreaded environment
 so that only one thread can execute the code at a time.
                 It helps to prevent race conditions when multiple threads try to access or modify the same data.
  When a thread enters a synchronized code:
  It acquires a lock (monitor) on an object
  Other threads wait until the lock is released
  When the thread exits the synchronized code, the lock is released automatically
Synchronized block: Lock is taken on specific object
                    Only the code inside the block is synchronized
                    Rest of the method runs without lock

      So, when the object is shared between multiple threads it will lead to incorrect results, critical section is
      a part of the program where the shared resources is being accessed, use synchronized key word there to reduce race condition

Mutual Exclusion in Java is a concurrency control mechanism that ensures only one thread at a time can access a shared resource or critical section, preventing data inconsistency and race conditions.
when a thread is executing a shared data it acquires lock on that

There are two types of lock:
1.Intrinsic: These are built into every object in Java. You don't see them but they are there. When you use a
synchronized keyword, you're using these automatic block.
There is a lock attached to every object internally.
2. Explicit: These are more advance locks you can control yourself using the Lock class from java.util.concurrent.locks.
You explicitly say when to lock or unlock, giving you more control over how and when people can write in the notebook for eg.

There are some drawbacks of synchronized keyword:
No other thread will execute that block or function until the current thread completes its execution including
the sleep task/period. The thread that acquires lock should complete its task entirely.
Imagine if Thread.sleep(100000) 100 sec pause , other threads will have to wait so long, inefficient
synchronized provides automatic locks,

Manual locks / Explicit locks : Lock is an interface, Lock lock = new ReentrantLock(); the thread which will acquire this lock are
only allowed to access critical section. Lock has some methods:
lock.lock(); : Thread trying to acquire lock.
lock.trylock() : acquires the lock only if it is free at the time of invocation, if not available then returns false
lock.unlocck() : giving lock to other thread

proceed with BankAccountLock class

if(lock.tryLock(1000, TimeUnit.MILLISECONDS)): Acquires the lock if it is free within the given waiting time and the current
thread has not been interrupted. lock.tryLock() does not wait.

In catch block, the information that the thread was interrupting will be lost, you can either re-throw it or manually re-interrupt
the current thread by calling Thread.interrupt(), potential impact is delaying the thread shutdown and losing the info
 that the thread was interrupted. Restore the interrupted thread state so that other threads can notice.
 The state of the interrupted state wil be interrupt, can be checked using isInterrupted

Reentrant Lock: lock(): waits indefinitely for the lock, unlock(): release the lock, trylock(): try to find lock once only,
other variant is time bounded where we specify the time period to wait. Deadlock prevention using ReentrantExample
lockInterruptibly() instaed of lock.lock(), when a thread is in blocked_waiting state waiting for other thread to complete
execution, this thread cannot interrupt the running thread, we can make this current thread interruptible using this method

unfairLock: private final Lock fairLock = new ReentrantLock(true); making fair parameter true, the lock will be acquired by the
threads in the order in which they are started.
Drawback of synchronization: 1. Fairness 2. Blocking 3. Interruptibility 4. Read/Write blocking
4. Synchronization cannot distinguish between read or write thread, t must allow read thread to access shared resource
  ReadWriteCounter.java RaedWriteLock interface allows multiple threads to read concurrently as long as no thread is writing to it.
  It ensures exclusive access for write operation, try this file

# Deadlock: Deadlock is a situation in multithreading where two or more threads are blocked forever, waiting for each other to release
a resource. This typically occurs when two or more threads have circular dependencies on a set of locks.

Deadlock typically occurs when four conditions are met simultaneously:
1. Mutual Exclusion:nOnly one thread can access a resource at a time.
2. Hold and Wait: A thread holding at least one resource is waiting to acquire additional resource held by other threads.
3. No preemption: Resource cannot be forcibly taken from threads holding them.
4. Circular Wait: A set of threads is waiting for each other in a circular chain.

# Thread Communication: Th a multithreaded environment, threads often needs to communicate and coordinate with each other
to accomplish a task. Without proper communication mechanisms, threads might end up in inefficient busy-waiting states,
leading to wastage of CPU resources and potential deadlocks.There are some methods:
wait(), notify(), notifyAll() can only be called within a synchronized context.

wait(): tells the current thread to stop and wait until other thread will notify you with notify() / notifyAll()

notify(): wakes up a single thread that is waiting

notifyAll(); wake up all the threads that are waiting

# Thread safety

The object or code is said to be thread safe when it guarantees no unexpected result or race condition will occur when multiple threads are
trying to access the object or block of code concurrently.
eg StringBuffer is thread safe but StringBuilder is not

# Thread using Lambda Expression

Runnable is an interface : A normal interface can have static methods, default methods, abstract methods. An interface with single abstract
methods is called functional interface. A functional interface only has one one abstract method without body.

Lambda Expressions are anonymous functions:
 public void func() {
   sout("Hello");               => lambda function =>   () -> { sout("Hello"); }
 }

remove accessmodifier, return type and functionname and put => betwen () and {}

We know Runnable has a single abstract method, we can create an object of implementation class(class implements runnable),
create anonymous class, or create a Lambda Expression that is run() method converted to expression

# Thread Pools: They are collection of pre-initialized threads to perform a task
Example, You opened a juice center, after some days the number od customers starts increasing, you start calling some of your friends to help
but there is no guarantee that all will come to help, so create a set of 2 to 3 friends in advance
why it matters: 1. Resource management: creating or destroying threads can be expensive, there is overhead, no proper management of resource
2. Response time:set of threads are already available
3. Control over Thread Count: can set a limit on the maximum threads you can create

Let us start this with executor framework
The Executor Framework in Java was introduced in Java 5 as a part of java.util.concurrent package to simplify the development
of concurrent application by abstracting away many of the complexities involved in creating and managing threads.

Problems occurred prior to executor frameworks:
Manual Thread Management
Resource Management
Scalability
Thread Reuse
Error Handling

There are three core interfaces in Executor Framework:
1. Executor 2. ExecutorService 3. ScheduledExecutorService

 * Create a thread pull with Executors.newFixedThreadPool(9), this returns ExecutorService;
 * This executorService has a submit() method that takes runnable logic as argument
 * executorService.shutdown() to stop the execution

Difference between Runnable and Callable:
 Runnable : used when no result need to be returned, run() method, cannot write throws in run() method signature
 Callable: used when you need to return something, call() method, method throws Exception no need of try/catch for Thread.sleep()

What we have seen so far: submit(runnable), submit(callable), shutdown(), shutdownnow(), awaitedTermination(), isShutDown()

There is a submit(runnable, result): to store result in future variable and access using get
isTerminated : returns true if all tasks have completed following shut down.

executorService.invokeAll();
//        Executes the given tasks, returning a list of Futures holding their status and results when all complete.
        Params:
//        tasks – the collection of tasks
//      Returns:
//        a list of Futures representing the tasks, in the same sequential order as produced by the iterator for the given task list, each of which has completed

methods associated with future object:
get(), isDone(), isCancelled(), get(time) wait for specified time
| Method          | Meaning                          |
| --------------- | -------------------------------- |
| `isCancelled()` | Was task cancelled?              |
| `isDone()`      | Completed OR cancelled OR failed |
| `cancel(false)` | Cancel result, not execution     |
| `cancel(true)`  | Interrupt execution              |

 3. ScheduledExecutorService: To perform task after some delay or periodically, regular interval.
 It extends ExecutorService which extends Executor
 It has a schedule method with 2 variants : with runnable and callable
 schedule () takes three parameters, first one is runnable/ callable , second is delay, third is timeUnit
 The task will be executed after specified delay.

 scheduledFixedRate():
 Meaning:
 scheduler.scheduleAtFixedRate(task, 0, 5, TimeUnit.SECONDS);
 ➡️ Run task every 5 seconds, counted from the start time of the previous run.

 Flow (simple):

 Task starts at 0 sec

 Next start at 5 sec

 Next at 10 sec

 Next at 15 sec

 ⏱️ Execution time is ignored

 scheduledFixedDelay:
 scheduler.scheduleWithFixedDelay(task, 0, 5, TimeUnit.SECONDS);
➡️ Wait 5 seconds after task finishes, then start again.

Flow (simple):

Task starts at 0 sec

Finishes at 3 sec

Next starts at 8 sec

Finishes at 11 sec

Next starts at 16 sec

⏳ Execution time is included

Summery: Core interfaces: Executor → ExecutorService → ScheduledExecutorService
         Thread pool creation: Executors.newFixedThreadPool(n) returns ExecutorService

         Task submission: submit(Runnable) and submit(Callable)

         Shutdown methods: shutdown(), shutdownNow(), awaitTermination()

         Runnable vs Callable:

         Runnable: no return value, run(), cannot throw checked exceptions

         Callable: returns value, call(), can throw exceptions

         Future usage: store task result, access via get()

         Future methods: get(), get(timeout), isDone(), isCancelled(), cancel(true/false)

         invokeAll(): executes multiple tasks and returns Future list in submission order

         Task state checks: isShutdown(), isTerminated()

         ScheduledExecutorService: runs tasks after delay or periodically

         Scheduling methods: schedule(), scheduleAtFixedRate(), scheduleWithFixedDelay()

         Fixed Rate: runs at regular start-time intervals

         Fixed Delay: waits for task completion before next run


